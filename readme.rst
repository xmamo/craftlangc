The CraftLang compiler
======================

This is a work in progress guide on the CraftLang programming language for Minecraft data packs and the CraftLang
compiler (craftlangc).

There isn’t a formal specification for the CraftLang programming language yet, as I don’t expect it to be stable yet.


Language basics
---------------

A simple CraftLang example
^^^^^^^^^^^^^^^^^^^^^^^^^^

In the following example, we’ll see an example for a CraftLang source file.  All CraftLang source files have a
structure similar to this::

	namespace this.is.my.namespace

	func1(): void
		a = <@e>
		b = <@s>
		if a > b
			/say Success
		else
			/say Failure

Let’s read the example from the top to the bottom.

A Minecraft data pack consists of functions; if there are many functions, they can be organized by separating them
between different folders.  The whole folder structure required for a data pack is automatically generated by
craftlangc.  In order to specify in which folder (or subfolder) all generated functions will be placed, a *namespace
declaration* is needed.  In this case, the namespace declaration is ``namespace this.is.my.namespace``, meaning that
all the resulting compiled functions will be callable from Minecraft with the command
``function this:is/my/namespace/<function-name>``.

Next, we have a *function definition*, which starts with ``func1(): void``.  This indicates that we want to define a
function called ``func1``, with no parameters, which returns nothing (``void``).  In the lines to follow, we have the
function body.  Like in Python, blocks of code are expressed by their indentation.

``a = <@e>`` and ``b = <@s>`` are two *assignment statements*.  CraftLang is a strongly typed language, like C, C++,
Java and C#; however, except when declaring a function, variable types are deduced by context, like in C# with ``var``
and in C++ with ``auto``.  In this case, ``<@e>`` and ``<@s>`` denote the entities ``@e`` and ``@s`` respectively;
therefore, the entity ``@e`` will be assigned to ``a`` and the entity ``@s`` will be assigned to ``b``, making both
``a`` and ``b`` entity variables.

Subsequently, we have an *if statement*, which starts with ``if a > b``.  Here we are testing whether the entities
assigned to ``a`` are a proper superset of the entities assigned to ``b`` (mathematically, we could denote using set
symbols: ``a ⊃ b``).  If this condition is fulfilled, the Minecraft command ``say Success`` will be executed,
otherwise ``say Failure`` will be executed.

Knowing that ``a`` is ``@e`` and ``b`` is ``@s``, we can deduce that ``a`` is a proper superset of ``b`` if and only if
``@e`` is a proper superset of ``@s``, which is true if and only if there’s at least one entity which is not ``@s``.

In this example, I purposely used the intermediate variables ``a`` and ``b``.  Of course, like in most programming
languages, arbitrary expressions are allowed instead of variables in most places::

	namespace this.is.my.namespace

	func1(): void
		if <@e> > <@s>
			/say Success
		else
			/say Failure


Defining a function
^^^^^^^^^^^^^^^^^^^

A CraftLang source file may have 0 or more functions defined after the mandatory namespace definition.  A function
definition consists of both a function signature and a function body.

A function signature has to be in the format::

	<func-name> '(' [func-params] ')' ':' <ret-type>

``func-params`` is an optional comma separated list which determines the parameters the function requires.  Each
parameter in the list has to be a unique identifier (that is, a letter character followed by 0 or more letter or digit
characters) followed by a colon (``:``) and a type.  Supported types for
parameters are ``boolean``, ``score`` and ``entity``.

``ret-type`` is the return type for the function.  It can be ``void``, ``boolean``, ``score`` or ``entity``.

Here are a few function signature examples::

	main(): void

::

	sum(a: score, b: score): score

::

	swap(a_ref: entity, b_ref: entity): void

::

	sin(angle: score): score

The function body for the defined function has to be a sequence of 1 or more statements adhering to the off-side
rule.  If, for some reason, you need a function which does nothing, you can use the *nop statement*::

	do_nothing(): void
		nop

In general, a nop statement can be used anywhere in the code, but it becomes useful when you are required to insert a
block of statements (function definitions, if statements, while statements) but want no functionality.

Statements
^^^^^^^^^^

Minecraft commands
""""""""""""""""""

CraftLang provides only a relatively thin level of abstraction over Minecraft data packs.  Most of the time, you’ll
want to get a command through the compilation.  Think of it as inline assembly, only that you’re going to use it much
more.

A command is denoted by a forward slash (``/``) followed by any number of characters.  Commands have to be on their own
line and cannot be part of any other statement or expression.

Here are a few examples for command statements::

	/say Hello, world!

::

	/execute if score @s some_score matches 0..10 run tellraw @a "Hello, world!"

::

	/function some_namespace:some/path/some_function


Assignments
"""""""""""

As mentioned in `A simple CraftLang example`_, the type of variables in the CraftLang programming language is
determined at compile time.  Something which in C would be ``int a = 1 + 2;`` simply becomes ``a = 1 + 2``.  ``1 + 2``
is an *expression*, where the *left-hand side* is ``1`` (a score) and the *right-hand side* is ``2`` (again, a score);
therefore, the whole expression is a score; therefore, ``a`` is assumed to be of type ``score``.

The value of a variable can be reassigned as many times as is deemed necessary, however its type can’t be changed after
the first assignment.  The scope of a variable is local to the block in which it was defined.

An assignment has to be in the format::

	<var-name> <assignment-operator> <expr>

``var-name`` has to be an identifier; ``assignment-operator`` has to be one of ``=``, ``*=``, ``/=``, ``%=``, ``+=``,
``-=``, ``&=``, ``^=``, ``|=``; ``expr`` has to be a valid expression, as defined in `Expressions`_.

Here are a few examples for assign statements::

	a = true | false
	a &= false

::

	b = 1 + 2 * 3
	b *= 10 / 2

::

	c = <@p[tag=t1]> | <@p[tag=t2]>
	c ^= <@p[tag=t3]>


Structured programming
""""""""""""""""""""""

Like almost all programming languages, CraftLang supports *structured programming*: there’s no way to perform goto-like
jumps.  As a matter of fact, not including gotos is not only a design choice, but a requirement: there’s no way to
achieve such functionality inside Minecraft functions.

CraftLang supports *if statements*, *while statements* and *do-while statements*.  The semantic of those statements is
practically identical to that of other programming languages; however, like in Java, the condition has to have a
boolean value: by design, it is not possible to have something like ``if (2 + 2) { /* ... */ }``, which would be
totally legal in languages like C.

An if statement has the following format::

	'if' <condition>
		<block>
	[else-part]

``else-part`` is optional.  It has the format::

	'else'
		<block>

A while statement has the following format::

	'while' <condition>
		<block>

A do-while statement has the following format::

	'do'
		<block>
	'while' <condition>

For each of the previous definitions, ``condition`` has to be a valid boolean expression, as defined in `Expressions`_.

Here are a few examples for those statements::

	if 2 > 1
		/say 2 > 1, OK
	else
		if 3 > 1
			/say Seems like 2 < 1.  Well, at least 3 > 1!

::

	a = 0
	while a < 10
		a += 1

::

	a = 0
	do
		a += 1
	while a < 10


Calling other functions
"""""""""""""""""""""""

It is possible to call functions from the body of another function, as long as there’s no explicit or implicit
recursion.  Recursive calls are prohibited by the CraftLang programming language as the only way to achieve such
functionality would be through a dynamic stack, which isn’t possible to recreate in a Minecraft function as of now.

Functions are called using the following format::

	<func-name> '(' [args] ')'

``args`` is an optional comma separated sequence of arguments to provide when calling the function.  Each argument can
have one of two formats:

* ``<expr>``, where ``expr`` has to be a valid expression, as defined in `Expressions`_;

* ``'ref' <id>``, where ``id`` is an identifier.

Expressions
^^^^^^^^^^^

Expressions are constructs that evaluate to a value.  They can:

* perform arithmetic operations between scores;

* perform set operations between entities;

* perform boolean operations between boolean values;

* perform comparaisons…

  * …between scores;

  * …between entities;

  * …between boolean values;

Below is a description of all operators and what they do.  The operators are listed according to precedence order.
Except for the negation operator, all operators are binary operators.

============================  ===============================================================
          Operator                                      Description
============================  ===============================================================
``!``                         Negation
``*``, ``/``, ``%``           Multiplication, division, remainder
``+``, ``-``                  Addition, subtraction
``<``, ``>``, ``<=``, ``>=``  Less than, greater than, less or equal to, greater or equal to
``==``, ``!=``                Equal to, not equal to
``&``                         AND
``^``                         XOR
``|``                         OR
============================  ===============================================================


Using the compiler
------------------

The compiler is invoked by running ``python craftlangc.pyz``. Two positional arguments are required: the *source file*
containing the CraftLang source and the *destination directory*, which tells the compiler where to put the compiled
functions.